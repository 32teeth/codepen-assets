<section>
  <h1>32teeth</h1>
  <h2>this pen needs ‚ù§</h2>
</section>
<canvas></canvas>

<style>
@charset 'UTF-8';
@import url('https://fonts.googleapis.com/css2?family=Poppins&display=swap:400,100,500,300italic,500italic,700italic,900,300');

body {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100vw;
  height: 100vh;
  flex-direction: column;
  font-family: 'Poppins';
  margin: 0;
  padding: 0;
}

canvas {
  position: absolute;
  width: 100vw;
  height: 100vh;
  border: solid;
  z-index: 3;
}

section {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  color: rgba(0, 0, 0, 0.25);
  z-index: -1;
  cursor: pointer;
}

section h1, section h2 {
  font-size: 2rem;
  margin: 0.25rem;
  transition: all ease 250ms
}

section h1 {
  border-style: solid;
  border-width: 2mm;
  border-radius: 10mm;
  font-size: 2rem;
  padding: 2mm 8mm;
}

section h2 {
  font-size: 1rem;
}

section:hover {
  color: rgba(0, 0, 0, 1);
}
</style>

<script>
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');
const width = canvas.width = window.innerWidth;
const height = canvas.height = window.innerHeight;
let opacity = 0;
const section = document.querySelector('section');
section.addEventListener('click', () => {
  balls.reset();
  explode.reset();
  balls.init();
  balls.draw();
  opacity = 0;
});

const explode = {
  decay: 50,
  particle: [],
  delay: 30,
  active: 0,
  reset: () => {
    explode.particle = [];
    explode.active = 0;
  },
  init: (x, y) => {
    explode.particle.push({
      x: x,
      y: y,
      r: 7,
      c: 5,
      dir: 1,
      state: true,
      wait: 0
    });
  },
  draw: () => {
    for (var n = 0; n < explode.particle.length; n++) {
      var p = explode.particle[n];
      ctx.fillStyle = `rgba(255, ${p.c}, 0.1`;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.closePath();
      ctx.beginPath();
      for (var a = 0; a <= p.r; a++) {
        var x = p.x + (p.r * Math.cos(a));
        var y = p.y + (p.r * Math.sin(a));
        var pixel = Math.floor(10 * (p.r / explode.decay));
        ctx.rect(x - (pixel / 2), y - (pixel / 2), pixel, pixel);
      }
      ctx.fill();
      ctx.closePath();
    }
  },
  update: () => {
    explode.active = 0;
    for (var n = 0; n < explode.particle.length; n++) {
      var p = explode.particle[n];
      if (p.r < explode.decay && p.state) {
        p.r += p.r / 5;
        p.c += parseInt(255 / explode.decay * 4);
        explode.active++
      } else {
        if (p.wait < explode.delay) {
          p.wait++;
          explode.active++;
        }
        if (p.r > 1 && p.wait == explode.delay) {
          p.r -= p.r / 10;
        } else {
          p.state = false;
        }
      }
    }
  }
}
const balls = {
  angle: 0,
  count: 250,
  particle: [],
  reset: () => {
    balls.particle = [];
  },
  init: () => {
    for (var n = 0; n < balls.count; n++) {
      balls.particle.push({
        x: Math.random() * width,
        y: Math.random() * height,
        r: 7,
        d: Math.random() * balls.count,
        dir: 1,
        speed: 0,
        base: Math.floor(Math.random() * 5),
        state: true
      })
    }
  },
  draw: () => {
    for (var n = 0; n < balls.count; n++) {
      var p = balls.particle[n];
      if (p.state) {
        ctx.fillStyle = 'rgba(153,153,153,1)';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.closePath();
        for (var i = 0; i < explode.particle.length; i++) {
          var e = explode.particle[i];
          var dx = p.x - e.x;
          var dy = p.y - e.y;
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < e.r + p.r) {
            balls.explode(p.x, p.y, n);
          }
        }
      }
    }
  },
  update: () => {
    for (var n = 0; n < balls.count; n++) {
      var p = balls.particle[n];
      if (p.state) {
        p.speed = (7 - Math.abs(parseInt((p.y - height / 2) / 16)));
        if (p.speed < 1) {
          p.speed = 2;
        }
        p.speed += p.base;
        p.y += p.speed * p.dir;
        if (p.y < p.r || p.y > height - p.r) {
          p.dir = -p.dir;
        }
      }
    }
  },
  explode: (x, y, n) => {
    if (balls.particle[n].state) {
      balls.particle[n].state = false;
      x = parseInt(x);
      y = parseInt(y);
      setTimeout(() => {
        explode.init(x, y);
        opacity++;
      }, 1);
    }
  }
}
balls.init();
balls.draw();
opacity = 0;


(loop = () => {
  requestAnimationFrame(loop);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  balls.draw();
  balls.update();
  explode.draw();
  explode.update();
  section.style.opacity = opacity/balls.particle.length;
  section.style.zIndex = -balls.particle.length + opacity + 10;
})();
canvas.addEventListener('mousedown', (e) => {
  explode.init(e.clientX, e.clientY);
}, false);
  </script>